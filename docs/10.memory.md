# 記憶庫與 RAG (檢索增強生成) 機制

根據專案的架構設計，記憶庫（RAG）主要分為 **寫入時機** 與 **搜尋與使用時機** 兩個主要部分。本文件詳細說明這兩大部分的運作流程。

## 一、RAG 何時會被寫入？

記憶庫目前主要有三種寫入機制，其中最重要的機制改為**「先暫存後確認」**：

### 1. AI 手動記憶（需要使用者確認）
- **關連檔案**：`docs/rag_write_confirmation.md`, `internal/memory/pending_store.go`, `tools/memory_save.go`
- **時機**：當你在對話中明確要求 AI 記住某些資訊（例如：「記住我喜歡喝咖啡」），AI 會呼叫 `memory_save` 工具。
- **寫入流程**：
  - 資料**不會立刻永久寫入**，而是進入 `PendingStore` 的未確認佇列（30 分鐘自動過期）。
  - AI 接著會反問你：「準備記住XXX，確認嗎？」
  - 只有當你回答「確認」時，AI 呼叫 `memory_confirm` 工具，才會正式寫入 `botmemory/knowledge/MEMORY.md`，並同步更新 SQLite 內的向量索引 (Vector DB)。

### 2. 對話自動紀錄（每日日誌儲存）
- **關連檔案**：`internal/history/history.go` (函式 `CheckAndSummarize`)
- **時機**：每次你送出訊息時（當系統啟動 `GlobalMemoryToolKit` 時）。
- **寫入流程**：使用者的發言會被即時寫進今日專屬的日誌檔 `botmemory/memory/YYYY-MM-DD.md`。這些紀錄之後會被分塊（Chunking）與向量嵌入（Embedding）並索引到 SQLite 資料庫。

### 3. 背景閒置歸納（舊版歷史濃縮備用機制）
- **關連檔案**：`internal/history/history.go` (函式 `CheckAndSummarize`)
- **時機**：當對話階段（Session）超時閒置逾 1 小時後自動觸發。
- **寫入流程**：系統會將這 1 小時內的對話重點提煉（精煉出3-5個關鍵字），儲存至長時間備份文件 `botmemory/history/auto_summaries.md`。

---

## 二、RAG 何時會用來搜尋/作為回答參考？

記憶檢索直接綁定在 **AI 回答生成前的攔截層**，分為**短期動態比對**與**長期向量搜尋**，讓它能不被察覺地自然提取背景知識：

### 1. 提問前的動態搜尋注入 (自動 RAG Context)
- **關連檔案**：`internal/agent/memory_context.go` (函式 `BuildMemorySearchFunc`)
- **時機**：每次發送提問前，系統都會預先拿你的「問題字詞」作為 Query 去執行 RAG 搜索，然後**混入這次發給 LLM 的隱含 Prompt 中**。
  - **短期記憶快速比對**：若你的問題出現了特定關鍵字（如：`天氣`、`行事曆`、`信件`等），系統會直接從 SQLite 短期資料表抓近 3 筆對應資料。
  - **長期記憶混合過濾（向量 + 關鍵字 BM25）**：將使用者的問題拿去資料庫做關聯強度比對（Threshold 需超過 `0.05`），最多取回前 3 筆切塊的記憶文字（每筆長度最多 1500 字元）。
- **注入結果**：一旦搜尋到高度關聯的背景知識，系統會將這段記憶預設為**「【最高優先級警告】這份背景代表實際的生活...你必須絕對無條件信任」**的嚴格前綴指令附加在 Prompt 開頭，確保 AI 根據你的真實背景回答。

### 2. 全域提示詞附帶 (靜態 System Prompt)
- **關連檔案**：`internal/history/rag.go` (函式 `GetRAGEnhancedPrompt`)
- **時機**：如果系統有長遠的核心 Bootstrap 記憶，或是單純沒找到高度關聯片段時作為兜底（Fallback），系統會直接把 `MEMORY.md` 內容（最高取到 4000 字）無條件當成系統提示詞的前綴「以下是你的長期記憶，可用於回答問題：」並塞入模型的上下文中。
